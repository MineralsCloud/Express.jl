var documenterSearchIndex = {"docs":
[{"location":"run/cli/#How-to-run-Express-from-command-line","page":"How to run Express from command line","title":"How to run Express from command line","text":"","category":"section"},{"location":"run/cli/","page":"How to run Express from command line","title":"How to run Express from command line","text":"To carry out a computation, first, users need to prepare the input files introduced in section \"Configuration files\". Then if the xps command is installed, run in terminal:","category":"page"},{"location":"run/cli/","page":"How to run Express from command line","title":"How to run Express from command line","text":"$ xps run eos.toml  # equation of state workflow\n$ xps run vdos.toml  # phonon workflow\n$ xps run qha.toml  # QHA workflow","category":"page"},{"location":"run/cli/","page":"How to run Express from command line","title":"How to run Express from command line","text":"As explained in \"Configuration files\", the file name (eos.toml, etc.) of the configuration file does not matter. It is the recipe field that determines the type of workflow.","category":"page"},{"location":"run/cli/","page":"How to run Express from command line","title":"How to run Express from command line","text":"It is often suggested to put the above commands in a script file with a header and submit it to a workload manager like Slurm. However, users can also request an interactive session and run code Julia REPL.","category":"page"},{"location":"run/cli/","page":"How to run Express from command line","title":"How to run Express from command line","text":"using Express.EquationOfStateWorkflow.Recipes\nusing QuantumESPRESSOExpress\nworkflow = buildworkflow(\"eos.toml\");\nrun!(workflow)","category":"page"},{"location":"run/cli/","page":"How to run Express from command line","title":"How to run Express from command line","text":"For phonon and the QHA workflow, run using Express.PhononWorkflow.Recipes and using Express.QuasiHarmonicApproxWorkflow.Recipes in the first step.","category":"page"},{"location":"run/cli/","page":"How to run Express from command line","title":"How to run Express from command line","text":"In an EOS workflow, the final results include outputs returned by Quantum ESPRESSO, a list of raw data (volume-energy pairs), and a fitted EOS. If something goes wrong, the workflow might be terminated. The state of the workflow (i.e., the status of each job) and errors will be saved in a file for debugging. Once the bug is fixed, run xps run <path-to-config-file> again, and express will retry the failed jobs. To print either input or output data in a formatted, readable form, run","category":"page"},{"location":"run/cli/","page":"How to run Express from command line","title":"How to run Express from command line","text":"$ xps print <file-name>","category":"page"},{"location":"run/cli/","page":"How to run Express from command line","title":"How to run Express from command line","text":"where the allowed extensions of <file-name> are .jls, .json, .yaml or .yml, and .toml. The last four extensions correspond to three human-readable data-serialization file formats, i.e., JSON, YAML, and TOML, while .jls is a binary serialization format only recognizable to Julia. For example,","category":"page"},{"location":"run/cli/","page":"How to run Express from command line","title":"How to run Express from command line","text":"$ xps print eos.toml\n$ xps print raw.json\n$ xps print eos.jls","category":"page"},{"location":"run/cli/","page":"How to run Express from command line","title":"How to run Express from command line","text":"express can also plot some data, such as the fitted EOS applied to a certain range of volumes along with the raw data. The corresponding command is","category":"page"},{"location":"run/cli/","page":"How to run Express from command line","title":"How to run Express from command line","text":"xps plot <file-name>","category":"page"},{"location":"run/cli/","page":"How to run Express from command line","title":"How to run Express from command line","text":"where <file-name> refers to the EOS binary file with extension .jls. These are the three most important commands of express. These catchy commands cover all the functionalities we have promised, including but not limited to unit conversion, pseudopotential downloading, input validation and generation, calculation monitoring, task distribution, gathering and analysis of results, error handling, logging, and visualization. We hope they can facilitate tedious work as much as possible.","category":"page"},{"location":"run/configuration/#Configuration-files","page":"Configuration files","title":"Configuration files","text":"","category":"section"},{"location":"run/configuration/","page":"Configuration files","title":"Configuration files","text":"Express can be run from a configuration file, with some preset rules. The following sections introduce how to write such configuration files. By now, only YAML, JSON, and TOML formats are supported. Please refer their official documentation for their syntax. In the examples below, we will use YAML syntax for configuration files. But for readability purposes, we suggest users use the TOML syntax.","category":"page"},{"location":"run/configuration/#Fitting-equations-of-state","page":"Configuration files","title":"Fitting equations of state","text":"","category":"section"},{"location":"run/configuration/","page":"Configuration files","title":"Configuration files","text":"The configuration file for the EOS workflow has the following syntax:","category":"page"},{"location":"run/configuration/","page":"Configuration files","title":"Configuration files","text":"recipe: A string that represents the type of the workflow. Allowed value is eos.\ntemplate: The path to a template input file for a specific software. It should be on the same file system where express is deployed.\ntrial_eos: The trial EOS contains initial values for input files generation and EOS fitting.\ntype: A string that represents the type of the EOS. Allowed values are murnaghan (Murnaghan), bm2 (Birch–Murnaghan second order), bm3, bm4, vinet (Vinet), pt2 (Poirier–Tarantola second order), pt3, and pt4.\nvalues: A vector of strings that specifies each value of the EOS. The default order is V_0, B_0, B_0(, B_0, etc.). Units must be provided.\nfixed:\npressures or volumes: Whether to fix pressures of volumes.\nvalues: Specify the pressures or volumes. It can be a vector of numbers, or a string with the syntax start:step:stop to form an arithmetic sequence where start, stop, and step are numbers indicating the start, the end, and the common difference of that sequence. See \"Creating arrays using range objects\" for more information.\nunit: The units of pressure or volume. The pressure and volume default units are GPa and angstrom^3. Allowed values for volumes are nm^3, angstrom^3, bohr^3, etc. Allowed values for pressures are Pa, GPa, TPa, ..., bar, kbar, ..., atm, and the combinations of eV, Ry, hartree, J, with any unit of volume.\nfiles:\ndirs: It specifies the paths of output directories.\nroot: The path of the root directory of output files.\npattern: A string specifying the naming convention of the output directories. Its default value is p=. For example, if fixed.pressures.values is a vector of pressures [10, 20, 30] which represents the relaxations are done from 10-30GPa, then the generated inputs and outputs will be stored in directories p=10, p=20 and p=30.\nsave:\nstatus: The path to a binary file that stores the status of the workflow.\neos: The path to a binary file that stores the fitted equations of state.\ncli:\nmpi: The configurations of the MPI software.\nnp: An integer indicating the number of processors/cores/CPUs used.","category":"page"},{"location":"run/configuration/","page":"Configuration files","title":"Configuration files","text":"The code block below shows a typical configuration file for an EOS workflow in the YAML syntax:","category":"page"},{"location":"run/configuration/","page":"Configuration files","title":"Configuration files","text":"recipe: eos\ncli:\n  mpi:\n    np: 16\ntemplate: template.in\nsave:\n  status: status.jls\nfixed:\n  pressures:\n    unit: GPa\n    values:\n      - -5\n      - -2\n      - 0\n      - 5\n      - 10\n      - 15\n      - 17\n      - 20\ntrial_eos:\n  type: bm3\n  values:\n    - 300.44 bohr^3\n    - 74.88 GPa\n    - 4.82","category":"page"},{"location":"run/configuration/","page":"Configuration files","title":"Configuration files","text":"The JSON and TOML equivalents of the above file are:","category":"page"},{"location":"run/configuration/","page":"Configuration files","title":"Configuration files","text":"{\n  \"recipe\": \"eos\",\n  \"cli\": {\n    \"mpi\": {\n      \"np\": 16\n    }\n  },\n  \"template\": \"template.in\",\n  \"save\": {\n    \"status\": \"status.jls\"\n  },\n  \"fixed\": {\n    \"pressures\": {\n      \"unit\": \"GPa\",\n      \"values\": [\n        -5,\n        -2,\n        0,\n        5,\n        10,\n        15,\n        17,\n        20\n      ]\n    }\n  },\n  \"trial_eos\": {\n    \"type\": \"bm3\",\n    \"values\": [\n      \"300.44 bohr^3\",\n      \"74.88 GPa\",\n      4.82\n    ]\n  }\n}","category":"page"},{"location":"run/configuration/","page":"Configuration files","title":"Configuration files","text":"recipe = 'eos'\ntemplate = 'template.in'\n[fixed.pressures]\nunit = 'GPa'\nvalues = [-5, -2, 0, 5, 10, 15, 17, 20]\n\n[trial_eos]\ntype = 'bm3'\nvalues = ['300.44 bohr^3', '74.88 GPa', 4.82]\n[cli.mpi]\nnp = 16\n\n[save]\nstatus = 'status.jls'","category":"page"},{"location":"run/configuration/#Phonon-density-of-states-or-phonon-dispersion-relation","page":"Configuration files","title":"Phonon density of states or phonon dispersion relation","text":"","category":"section"},{"location":"run/configuration/","page":"Configuration files","title":"Configuration files","text":"The configuration file for the phonon workflow has the following syntax:","category":"page"},{"location":"run/configuration/","page":"Configuration files","title":"Configuration files","text":"recipe: A string that represents the type of the workflow. Allowed values are phonon dispersion (phonon dispersion along a q-path) and vdos (phonon density of states).\ntemplate:\nscf: The path to a template input file for an SCF calculation.\ndfpt: The path to a template input file for a DFPT calculation.\nq2r: The path to a template input file for a Fourier transform.\ndisp: The path to a template input file for a phonon dispersion/phonon density of states calculation.\nfixed:\npressures or volumes: Whether to fix pressures of volumes.\nvalues: Specify the pressures or volumes. It can be a vector of numbers, or a string with the syntax start:step:stop to form an arithmetic sequence where start, stop, and step are numbers indicating the start, the end, and the common difference of that sequence. See \"Creating arrays using range objects\" for more information.\nunit: The units of pressure or volume. The pressure and volume default units are GPa and angstrom^3. Allowed values for volumes are nm^3, angstrom^3, bohr^3, etc. Allowed values for pressures are Pa, GPa, TPa, ..., bar, kbar, ..., atm, and the combinations of eV, Ry, hartree, J, with any unit of volume.\nfiles:\ndirs: It specifies the paths of output directories.\nroot: The path of the root directory of output files.\npattern: A string specifying the naming convention of the output directories. Its default value is p=. For example, if fixed.pressures.values is a vector of pressures [10, 20, 30] which represents the relaxations are done from 10-30GPa, then the generated inputs and outputs will be stored in directories p=10, p=20 and p=30.\nsave:\nstatus: The path to a binary file that stores the status of the workflow.\ncli:\nmpi: The configurations of the MPI software.\nnp: An integer indicating the number of processors/cores/CPUs used.","category":"page"},{"location":"run/configuration/","page":"Configuration files","title":"Configuration files","text":"The code block below shows a typical configuration file for a phonon workflow in the YAML syntax:","category":"page"},{"location":"run/configuration/","page":"Configuration files","title":"Configuration files","text":"recipe: vdos\ncli:\n  mpi:\n    np: 16\ntemplate:\n  scf: template.in\n  dfpt: ph.in\n  q2r: q2r.in\n  disp: disp.in\nsave:\n  status: status.jls\nfixed:\n  pressures:\n    unit: GPa\n    values:\n      - -5\n      - -2\n      - 0\n      - 5\n      - 10\n      - 15\n      - 17\n      - 20","category":"page"},{"location":"run/configuration/","page":"Configuration files","title":"Configuration files","text":"The JSON and TOML equivalents of the above file are:","category":"page"},{"location":"run/configuration/","page":"Configuration files","title":"Configuration files","text":"{\n  \"recipe\": \"vdos\",\n  \"cli\": {\n    \"mpi\": {\n      \"np\": 16\n    }\n  },\n  \"template\": {\n    \"scf\": \"template.in\",\n    \"dfpt\": \"ph.in\",\n    \"q2r\": \"q2r.in\",\n    \"disp\": \"disp.in\"\n  },\n  \"save\": {\n    \"status\": \"status.jls\"\n  },\n  \"fixed\": {\n    \"pressures\": {\n      \"unit\": \"GPa\",\n      \"values\": [\n        -5,\n        -2,\n        0,\n        5,\n        10,\n        15,\n        17,\n        20\n      ]\n    }\n  }\n}","category":"page"},{"location":"run/configuration/","page":"Configuration files","title":"Configuration files","text":"recipe = 'vdos'\n[cli.mpi]\nnp = 16\n\n[template]\ndfpt = 'ph.in'\ndisp = 'disp.in'\nq2r = 'q2r.in'\nscf = 'template.in'\n[fixed.pressures]\nunit = 'GPa'\nvalues = [-5, -2, 0, 5, 10, 15, 17, 20]\n\n[save]\nstatus = 'status.jls'","category":"page"},{"location":"develop/#How-to-develop-this-package","page":"Development","title":"How to develop this package","text":"","category":"section"},{"location":"develop/#Download-the-project","page":"Development","title":"Download the project","text":"","category":"section"},{"location":"develop/","page":"Development","title":"Development","text":"First, add an SSH key to your GitHub account. Request or wait for the administrator of this repo to give you an invitation for triage.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"Then, similar to section \"Installation\", run","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"using Pkg\nPkg.update();\npkg\"dev Express\";","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"Then the package will be cloned to your local machine at a path. On Unix-like systems, by default is located at ~/.julia/dev/Express unless you modify the JULIA_DEPOT_PATH environment variable (See Julia's official documentation). In the following text, we will call it PKGROOT.","category":"page"},{"location":"develop/#instantiating","page":"Development","title":"Instantiate the project","text":"","category":"section"},{"location":"develop/","page":"Development","title":"Development","text":"Go to PKGROOT, start a new Julia session and run","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"using Pkg\nPkg.instantiate();","category":"page"},{"location":"develop/#How-to-build-docs","page":"Development","title":"How to build docs","text":"","category":"section"},{"location":"develop/","page":"Development","title":"Development","text":"Usually, the up-to-state doc is available in here, but there are cases where users need to build the doc themselves.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"After instantiating the project, go to PKGROOT, run (without the $ prompt)","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"$ julia --color=yes docs/make.jl","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"in your terminal. In a while a folder PKGROOT/docs/build will appear. Open PKGROOT/docs/build/index.html with your favorite browser and have fun!","category":"page"},{"location":"develop/#How-to-run-tests","page":"Development","title":"How to run tests","text":"","category":"section"},{"location":"develop/","page":"Development","title":"Development","text":"After instantiating the project, go to PKGROOT, run (without the $ prompt)","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"$ julia --color=yes test/runtests.jl","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"in your terminal.","category":"page"},{"location":"troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"This page collects some possible errors you may encounter and trick how to fix them.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you have additional tips, please submit a PR with suggestions.","category":"page"},{"location":"troubleshooting/#Installation-problems","page":"Troubleshooting","title":"Installation problems","text":"","category":"section"},{"location":"troubleshooting/#Cannot-find-the-Julia-executable","page":"Troubleshooting","title":"Cannot find the Julia executable","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Make sure you have Julia installed in your environment. Please download the latest stable version for your platform. If you are using macOS, the recommended way is to use Homebrew. If you do not want to install Homebrew or you are using other platforms that Julia supports, download the corresponding binaries. And then create a symbolic link /usr/local/bin/julia to the Julia executable. If /usr/local/bin/ is not in your $PATH, export it to your $PATH. Some clusters, like Habanero, Comet, or Expanse, already have Julia installed as a module, you may just module load julia to use it. If not, either install by yourself or contact your administrator.","category":"page"},{"location":"troubleshooting/#Have-trouble-installing-[qha](https://github.com/MineralsCloud/qha)","page":"Troubleshooting","title":"Have trouble installing qha","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you are seeing error message like this:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"ERROR: LoadError: InitError: PyError (PyImport_ImportModule\n\nThe Python package qha could not be imported by pyimport. Usually this means\nthat you did not install qha in the Python version being used by PyCall.\n\nPyCall is currently configured to use the Python version at:\n\n/usr/bin/python3\n\nand you should use whatever mechanism you usually use (apt-get, pip, conda,\netcetera) to install the Python package containing the qha module.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"It is because on some operating systems, python is already installed, and Julia selects it as the default binary. But that python cannot install third-party Python packages. So qha cannot be automatically installed by Julia.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"One solution is to re-configure PyCall to use a different Python version on your system: set ENV[\"PYTHON\"] to the path of the python executable you want to use, run Pkg.build(\"PyCall\"), and re-launch Julia. For example, in Julia REPL, run","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"using Pkg\nENV[\"PYTHON\"] = \"... path of the python executable ...\"\n# ENV[\"PYTHON\"] = raw\"C:\\Python37-x64\\python.exe\" # example for Windows, \"raw\" to not have to escape: \"C:\\\\Python37-x64\\\\python.exe\"\n# ENV[\"PYTHON\"] = \"/usr/bin/python3.7\"            # example for *nix\nPkg.build(\"PyCall\");","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Please see this part for more detailed instructions.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Another solution is to configure PyCall to use a Julia-specific Python distribution via the Conda.jl package (which installs a private Anaconda Python distribution), which has the advantage that packages can be installed and kept up-to-date via Julia. As explained in the PyCall documentation, in Julia, run","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"using Pkg\nENV[\"PYTHON\"] = \"\" # empty string\nPkg.build(\"PyCall\");","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Then re-launch Julia.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If qha still cannot be installed, go to the Python binary directory you specified (for the second solution, go to $JULIA_DEPOT_PATH/conda/3/bin) and run the following command","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"$ ./pip install qha","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"note: Note\nAt least Python 3.6 and above is required to install qha. Please read its manual for more information.","category":"page"},{"location":"troubleshooting/#Loading-settings","page":"Troubleshooting","title":"Loading settings","text":"","category":"section"},{"location":"troubleshooting/#Error-parsing-YAML-files","page":"Troubleshooting","title":"Error parsing YAML files","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you encounter","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"ERROR: expected '<document start>' but found YAML.BlockMappingStartToken at nothing","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"or","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"ERROR: while scanning a simple key at line n, column 0: could not find expected ':' at line n+1, column 0","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Check whether you have no space between the YAML key and its value like key:1 or key:some text, etc. To correct, change to key: 1, key: some text, etc. Otherwise, check other YAML syntax you may have broken.","category":"page"},{"location":"troubleshooting/#Loading-Express","page":"Troubleshooting","title":"Loading Express","text":"","category":"section"},{"location":"troubleshooting/#Why-is-Julia-compiling/loading-modules-so-slow?-What-can-I-do?","page":"Troubleshooting","title":"Why is Julia compiling/loading modules so slow? What can I do?","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"First, we recommend you download the latest version of Julia. Usually, the newest version has the best performance.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you just want Julia to do a simple task and only once, you could start Julia REPL with","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"$ julia --compile=min","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"to minimize compilation or","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"$ julia --optimize=0","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"to minimize optimizations, or just use both. Or you could make a system image and run with","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"$ julia --sysimage custom-image.so","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"See Fredrik Ekre's talk for details.","category":"page"},{"location":"troubleshooting/#Miscellaneous-errors","page":"Troubleshooting","title":"Miscellaneous errors","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you see the following error message\njulia> w = buildworkflow(\"eos.toml\");\nERROR: MethodError: Cannot `convert` an object of type Dict{String, Any} to an object of type AbInitioSoftwareBase.Commands.CommandConfig\nClosest candidates are:\n  convert(::Type{T}, ::Intervals.AnchoredInterval{P, T}) where {P, T} at ~/.julia/packages/Intervals/ua9cq/src/anchoredinterval.jl:181\n  convert(::Type{T}, ::Intervals.Interval{T}) where T at ~/.julia/packages/Intervals/ua9cq/src/interval.jl:253\n  convert(::Type{T}, ::P) where {T, P<:(Polynomials.AbstractPolynomial{T})} at ~/.julia/packages/Polynomials/WvTSC/src/common.jl:434\n  ...\nThen you probably forget loading a plugin package for Express.jl. For example, you should run\nusing QuantumESPRESSOExpress\nto fix this error.","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Here are the installation instructions for Express.jl. If you have trouble installing it, please refer to our Troubleshooting page for more information.","category":"page"},{"location":"install/#Install-Julia","page":"Installation","title":"Install Julia","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"First, you should install Julia. We recommend downloading it from its official website. Please follow the detailed instructions on its website if you have to build Julia from source. Some computing centers provide preinstalled Julia. Please contact your administrator for more information in that case.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If you have Homebrew installed, open Terminal.app and type","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"$ brew install --cask julia","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"if you want to install it as a prebuilt binary app. Type","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"$ brew install julia","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"if you want to install it as a formula.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If you want to install multiple Julia versions in the same operating system, a suggested way is to use a version manager such as asdf. First, install asdf. Then, run","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"$ asdf install julia 1.6.5   # or other versions of Julia\n$ asdf global julia 1.6.5","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"to install Julia and set v1.6.5 as a global version.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"You can also try another cross-platform installer for the Julia programming language juliaup.","category":"page"},{"location":"install/#Compatibility","page":"Installation","title":"Compatibility","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Versions higher than v1.3, especially v1.6, are strongly recommended. This package may not work on v1.0 and below. Since the Julia team has set v1.6 as the long-term support (LTS) release, support for versions below v1.6 will gradually drop.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Julia and Julia packages support multiple operating systems and CPU architectures; check this table to see if it can be installed on your machine. For Mac computers with M-series processors, this package and its dependencies may not work. Please install the Intel-compatible version of Julia (for macOS x86).","category":"page"},{"location":"install/#Install-Express","page":"Installation","title":"Install Express","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Now I am using macOS as a standard platform to explain the following steps:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Open Terminal.app, and type julia to start an interactive session (known as REPL).\nRun the following commands and wait for them to finish:\nusing Pkg\nPkg.update();\nPkg.add(\"Express\");\nRun\nusing Express\nand have fun!\nWhile using, please keep this Julia session alive. Restarting might recompile the package and cost some time.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If you want to install the latest in development (maybe buggy) version of Express, type","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.update();\npkg\"add Express#master\";","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"in the second step instead.","category":"page"},{"location":"install/#Update-Express","page":"Installation","title":"Update Express","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Please watch our GitHub repository for new releases. Once we release a new version, you can update Express by typing","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.update(\"Express\");\nPkg.gc();","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"in Julia REPL.","category":"page"},{"location":"install/#Uninstall-and-reinstall-Express","page":"Installation","title":"Uninstall and reinstall Express","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"To uninstall, in a Julia session, run\nusing Pkg\nPkg.rm(\"Express\");\nPkg.gc();\nPress ctrl+d to quit the current session. Start a new Julia session and reinstall Express.","category":"page"},{"location":"install/#Install-a-plugin-for-express","page":"Installation","title":"Install a plugin for express","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Plugins are packages that handle ab initio software such as Quantum ESPRESSO in the express framework. The current plugin is QuantumESPRESSOExpress. To install QuantumESPRESSOExpress.jl, run","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.update();\nPkg.add(\"QuantumESPRESSOExpress\");","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"in Julia REPL.","category":"page"},{"location":"install/#cli","page":"Installation","title":"Install command-line tools","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"We provide a command-line interface of express for non-developers: ExpressCommands.jl. It installs an executable 'xps' that can execute code from configuration files provided by users. To install ExpressCommands, run","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"using Pkg\nPkg.update();\nPkg.add(\"ExpressCommands\");","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"in Julia REPL.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"After installation, the path to xps is $HOME/.julia/bin/xps by default. So please add $HOME/.julia/bin to your PATH environment variable.","category":"page"},{"location":"api/EquationOfStateWorkflow/#Express.EquationOfStateWorkflow-module","page":"EquationOfStateWorkflow module","title":"Express.EquationOfStateWorkflow module","text":"","category":"section"},{"location":"api/EquationOfStateWorkflow/","page":"EquationOfStateWorkflow module","title":"EquationOfStateWorkflow module","text":"Modules = [Express.EquationOfStateWorkflow]","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Express","category":"page"},{"location":"#Express:-an-extensible,-lightweight,-high-throughput,-high-level-workflow-framework-that-aims-to-automate-*ab-initio*-calculations","page":"Home","title":"Express: an extensible, lightweight, high-throughput, high-level workflow framework that aims to automate ab initio calculations","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Express.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Express is an extensible, high-throughput, high-level workflow framework that aims to automate ab initio calculations for the materials science community. Express is shipped with well-tested workflow templates, including structure optimization, equation of state (EOS) fitting, phonon spectrum (lattice dynamics) calculation, and thermodynamic property calculation in the framework of the quasi-harmonic approximation (QHA). It is designed to be highly modularized so that its components can be reused across various occasions, and customized workflows can be built on top of that.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The differences between express and Express: express is the project's name, it is a collection of Julia packages. Its core is Express.jl, managing and dispatching the rest packages. Express is short for Express.jl, which is the most important component of express. The direct components of express are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: components)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Express.jl provides a high-level interface to all the workflows, including file reading and writing, job creation, submission, monitoring, result retrieving, and data analysis. To work with specific software, install the corresponding plugin, e.g., QuantumESPRESSOExpress.jl for Quantum ESPRESSO.\nExpressCommands.jl is a user-friendly command-line interface of Express.jl for non-developers. It installs an executable 'xps' that can execute code from configuration files provided by users.\nEquationsOfStateOfSolids.jl fits energy (or pressure) vs. volume results to equations of state, etc. These features are repetitively used in the equation of state workflow.\nCrystallography.jl calculates a crystal's primitive cell (or supercell) volume from lattice parameters, finds symmetry operations and generates high symmetry points in the Brillouin zone, etc.\nPyQHA.jl is a Julia wrapper of the Python qha package, which can calculate several thermodynamic properties of both single- and multi-configuration crystalline materials in the framework of quasi-harmonic approximation (QHA). The qha code is the foundation of the QHA workflow.\nGeotherm.jl is a Julia interpretation of the Fortran code we used in this paper, which calculates the isentropic temperature/pressure gradient (geotherm) using thermodynamic properties obtained with the QHA workflow.\nPseudopotentials.jl presents a database for storing and querying pseudopotentials used in ab initio calculations.\nSimpleWorkflows.jl is the skeleton of the workflow system, which defines building blocks, composition rules, and operation order of workflows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The QuantumESPRESSOExpress.jl is a special type of package called \"plugin of express\" for handling ab initio software such as Quantum ESPRESSO. Other plugins for other software are possible. The dependencies of QuantumESPRESSOExpress.jl are listed below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"AbInitioSoftwareBase.jl provides a standard API for some popular ab initio software such as Quantum ESPRESSO.\nQuantumESPRESSOBase.jl declares basic data types and methods for manipulating crystal structures, generating input files for Quantum ESPRESSO, error checking before running, etc.\nQuantumESPRESSOParser.jl parses the input or output files of Quantum ESPRESSO to extract and analyze data.\nQuantumESPRESSOFormatter.jl formats the input files of Quantum ESPRESSO.\nQuantumESPRESSOCommands.jl is a command-line interface that exports the commands Quantum ESPRESSO uses in a configurable way.\nQuantumESPRESSO.jl is simply a wrapper of the types, methods, and commands defined in QuantumESPRESSOBase.jl, QuantumESPRESSOParser.jl, QuantumESPRESSOFormatter.jl, and QuantumESPRESSOCommands.jl under a common namespace.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"install.md\",\n    \"develop.md\",\n    \"configuration.md\",\n    \"troubleshooting.md\",\n    \"api/EquationOfStateWorkflow.md\",\n]\nDepth = 3","category":"page"},{"location":"#main-index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"questions/#Some-other-questions-about-Express","page":"Other questions","title":"Some other questions about Express","text":"","category":"section"},{"location":"questions/#What-is-the-difference-between-Express-and-express?","page":"Other questions","title":"What is the difference between Express and express?","text":"","category":"section"},{"location":"questions/","page":"Other questions","title":"Other questions","text":"express is the workflow framework's name, while Express is the short form of Express.jl, the Julia implementation of express. We do not want the project's name linked to a specific programming language: who says we cannot have a Python version of express in the future?","category":"page"},{"location":"questions/#Why-do-you-create-express,-given-that-[AiiDA](https://www.aiida.net/),-[ASE](https://gitlab.com/ase/ase),-[atomate](https://atomate.org/),-etc.,-are-already-there?","page":"Other questions","title":"Why do you create express, given that AiiDA, ASE, atomate, etc., are already there?","text":"","category":"section"},{"location":"questions/","page":"Other questions","title":"Other questions","text":"Those projects are of very high quality and are de facto standards of the materials simulation community. They have much larger teams and longer history than us, so it is unrealistic to say we are better than them in every aspect in the first few releases of express. However, it does not mean we cannot have our features or advantages. Our code is better at modularity, extensibility, and readability.","category":"page"},{"location":"questions/","page":"Other questions","title":"Other questions","text":"First, some packages only implement workflows for specific software. By far, Quantum ESPRESSO is only supported by a few packages. Even the largest one, Aiida, covers limited use cases of Quantum ESPRESSO. Considering the number of users in the Quantum ESPRESSO community (1000-2000 citations per year), there is a great need for an advanced and eclectic workflow ecosystem.","category":"page"},{"location":"questions/","page":"Other questions","title":"Other questions","text":"Second, most of their effort is put into dealing with servers, networks, databases, web interfaces, file formats, etc., while the code's core logic takes up only a small part, leaving gigantic packages that are hard to understand and integrate into users' code. On the contrary, express is a highly modularized collection of packages, with each of them providing a succinct, almost independent, complete set of functionalities frequently used in materials modeling. Inside each package, every type and function are also loosely coupled. Users can pick up pieces of our code and incorporate them into theirs effortlessly. It is also possible for users to build customized workflows. In fact, each workflow in Express.jl is just a collection of predefined wrappers of functions provided by its dependencies. Part of the express project can be installed and used if necessary. For example, Pseudopotentials.jl, Crystallography.jl, EquationsOfStateOfSolids.jl, and QuantumESPRESSO.jl, are distinct packages. They can work together to form the equation of state workflow. They can also work separately, such as managing pseudopotentials, calculating structural symmetry, fitting existing data.","category":"page"},{"location":"questions/","page":"Other questions","title":"Other questions","text":"In addition, many packages mentioned above are implemented in Python, a convenient language when building a prototype project but not the most convenient one when developing a large project due to readability and performance issues (For this reason, Dropbox, Inc. is writing a static type checker mypy to make large Python programs easier to read, and people are working on a faster Python implementation called PyPy.). However, Julia has built-in support for type annotations, making it extremely readable and performant. Namely, it is easy to write generic Julia code without losing performance. Another benefit of using Julia is good compatibility between codebases. Because of its multimethods feature, different Julia packages usually just \"magically\" work together. For example, our users never need to convert units. With the help of Unitful.jl, we can always write literal units obtained from experiments and do not need to consider whether they are the same or not. This is helpful when fitting equations of state, modifying crystal structures, etc. We usually do not have such flexibility in other languages, including Python, where sometimes wrapper code is needed. From the developers' perspectives, we seldom need to adapt to others' code. From the users' perspectives, they can use customized data structures without worrying about code incompatibility.","category":"page"},{"location":"questions/","page":"Other questions","title":"Other questions","text":"At last, some of the workflows we shipped in express are uniquely developed by us. See the introduction of the qha package, which can calculate quasiharmonic free energy for multi-configuration systems. We also have some workflows that will be integrated into express shortly, including but not limited to, the phonon gas model workflow that was used to calculate thermodynamic properties of ε-Fe with thermal electronic excitation effects on vibrational spectra, and the thermoelasticity workflow based on the Wu–Wentzcovitch semi-analytical method (SAM).","category":"page"}]
}
