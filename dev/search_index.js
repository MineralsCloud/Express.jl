var documenterSearchIndex = {"docs":
[{"location":"examples/GaN/#hcp-GaN-example","page":"hcp-GaN example","title":"hcp-GaN example","text":"","category":"section"},{"location":"examples/GaN/#Fitting-equations-of-state","page":"hcp-GaN example","title":"Fitting equations of state","text":"","category":"section"},{"location":"examples/GaN/#Run-interactively","page":"hcp-GaN example","title":"Run interactively","text":"","category":"section"},{"location":"examples/GaN/","page":"hcp-GaN example","title":"hcp-GaN example","text":"Install the latest version of Julia (as new as you can). Install this package as instructed in \"Installation\" section.","category":"page"},{"location":"examples/GaN/","page":"hcp-GaN example","title":"hcp-GaN example","text":"After the last command, this repo will be cloned to DEPOT_PATH. On a *nix system, it is usually ~/.julia/dev/. Go to this ~/.julia/dev/Express, start your VS Code or Atom at exactly there. Open a Julia REPL in your VS Code/Atom, run","category":"page"},{"location":"examples/GaN/","page":"hcp-GaN example","title":"hcp-GaN example","text":"julia> using Express.EquationOfStateWorkflow.Recipes\n\njulia> config = \"<PATH-TO-EXPRESS>/examples/GaN/eos.yaml\";\n\njulia> buildworkflow(config)","category":"page"},{"location":"examples/GaN/","page":"hcp-GaN example","title":"hcp-GaN example","text":"Then it will start running scf calculations on different pressures. You can type scfjobs in terminal at any time to inquire the status of the jobs. When they are running, a 🚧 emoji will be shown. If succeeded, a ✅ will be shown. If failed, a ❌ will be shown.","category":"page"},{"location":"examples/GaN/","page":"hcp-GaN example","title":"hcp-GaN example","text":"When all jobs are finished (you need at least 6 pressures finished), run","category":"page"},{"location":"examples/GaN/","page":"hcp-GaN example","title":"hcp-GaN example","text":"julia> postprocess(SelfConsistentField(), config)  # Step 3\nEquationsOfState.Collections.BirchMurnaghan3rd{Unitful.Quantity{Float64,D,U} where U where D}\n v0 = 317.7479585715598 a₀³\n b0 = 172.85031797933803 GPa\n b′0 = 4.379649372725796\n e0 = -612.4315064611411 Ry","category":"page"},{"location":"examples/GaN/","page":"hcp-GaN example","title":"hcp-GaN example","text":"An equation of state, with units, will be shown.","category":"page"},{"location":"examples/GaN/","page":"hcp-GaN example","title":"hcp-GaN example","text":"The next 3 steps are basically the same, just with VariableCellOptimization as calculation type.","category":"page"},{"location":"examples/GaN/","page":"hcp-GaN example","title":"hcp-GaN example","text":"julia> preprocess(VariableCellOptimization(), config)  # Step 1\n\njulia> vcjobs = process(VariableCellOptimization(), config)  # Step 2\n\njulia> postprocess(VariableCellOptimization(), config)\nEquationsOfState.Collections.BirchMurnaghan3rd{Unitful.Quantity{Float64,D,U} where U where D}\n v0 = 317.7517433287492 a₀³\n b0 = 172.74897940782353 GPa\n b′0 = 4.388034458575274\n e0 = -612.4315074654779 Ry","category":"page"},{"location":"examples/GaN/","page":"hcp-GaN example","title":"hcp-GaN example","text":"When it is calling Quantum ESPRESSO to do the calculations, it looks like the REPL got stuck, but it is not. Just wait! Do not stop the REPL! Each scf calculation will take about 2 minutes on 2 processors, and each vc-relax calculation will take about 6-9 minutes. So it might need 2-3 hours to run the whole workflow, depending on how good your computer is.","category":"page"},{"location":"examples/GaN/#Run-using-a-script","page":"hcp-GaN example","title":"Run using a script","text":"","category":"section"},{"location":"examples/GaN/","page":"hcp-GaN example","title":"hcp-GaN example","text":"When running on a high performance computer, it is always recommended to first start a debugging/developing environment, do a small test to make sure that inputs can be generated and job can be submitted. Then to scale your calculation, write the above commands in a Julia script and submit it to a schedule manager. That is, write","category":"page"},{"location":"examples/GaN/","page":"hcp-GaN example","title":"hcp-GaN example","text":"using Express.EquationOfStateWorkflow\n\nconfig = \"<PATH-TO-EXPRESS>/examples/GaN/eos.yaml\"\npreprocess(SelfConsistentField(), config)  # Step 1\nscfjobs = process(SelfConsistentField(), config)  # Step 2\nprint(postprocess(SelfConsistentField(), config))  # Step 3\npreprocess(VariableCellOptimization(), config)  # Step 4\nvcjobs = process(VariableCellOptimization(), config)  # Step 5\nprint(postprocess(VariableCellOptimization(), config))  # Step 6","category":"page"},{"location":"examples/GaN/","page":"hcp-GaN example","title":"hcp-GaN example","text":"to a .jl file, say GaN.jl. If you are using Slurm, then write a job.sh with","category":"page"},{"location":"examples/GaN/","page":"hcp-GaN example","title":"hcp-GaN example","text":"#!/bin/sh\n#SBATCH -A <your-account>\n#SBATCH -N 1\n#SBATCH --tasks-per-node=24\n#SBATCH -J job\n#SBATCH --time=02:00:00\n\njulia <PATH-TO-GaN.jl>","category":"page"},{"location":"examples/GaN/","page":"hcp-GaN example","title":"hcp-GaN example","text":"Then submit it using sbatch job.sh.","category":"page"},{"location":"develop/#How-to-develop-this-package","page":"Development","title":"How to develop this package","text":"","category":"section"},{"location":"develop/#Download-the-project","page":"Development","title":"Download the project","text":"","category":"section"},{"location":"develop/","page":"Development","title":"Development","text":"First, add an SSH key to your GitHub account. Request or wait for the administrator of this repo to give you an invitation for triage.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"Then, similar to section \"Installation\", run","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"julia> using Pkg; Pkg.update()\n\njulia> pkg\"dev Express\"","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"Then the package will be cloned to your local machine at a path. On macOS, by default is located at ~/.julia/dev/Express unless you modify the JULIA_DEPOT_PATH environment variable. (See Julia's official documentation on how to do this.) In the following text, we will call it PKGROOT.","category":"page"},{"location":"develop/#instantiating","page":"Development","title":"Instantiate the project","text":"","category":"section"},{"location":"develop/","page":"Development","title":"Development","text":"Go to PKGROOT, start a new Julia session and run","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"julia> using Pkg; Pkg.instantiate()","category":"page"},{"location":"develop/#How-to-build-docs","page":"Development","title":"How to build docs","text":"","category":"section"},{"location":"develop/","page":"Development","title":"Development","text":"Usually, the up-to-state doc is available in here, but there are cases where users need to build the doc themselves.","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"After instantiating the project, go to PKGROOT, run (without the $ prompt)","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"$ julia --color=yes docs/make.jl","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"in your terminal. In a while a folder PKGROOT/docs/build will appear. Open PKGROOT/docs/build/index.html with your favorite browser and have fun!","category":"page"},{"location":"develop/#How-to-run-tests","page":"Development","title":"How to run tests","text":"","category":"section"},{"location":"develop/","page":"Development","title":"Development","text":"After instantiating the project, go to PKGROOT, run (without the $ prompt)","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"$ julia --color=yes test/runtests.jl","category":"page"},{"location":"develop/","page":"Development","title":"Development","text":"in your terminal.","category":"page"},{"location":"troubleshooting/#Troubleshooting","page":"Troubleshooting","title":"Troubleshooting","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Pages = [\"troubleshooting.md\"]","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"This page collects some possible errors you may encounter and trick how to fix them.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you have additional tips, please submit a PR with suggestions.","category":"page"},{"location":"troubleshooting/#Installation-problems","page":"Troubleshooting","title":"Installation problems","text":"","category":"section"},{"location":"troubleshooting/#Cannot-find-the-Julia-executable","page":"Troubleshooting","title":"Cannot find the Julia executable","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Make sure you have Julia installed in your environment. Please download the latest stable version for your platform. If you are using macOS, the recommended way is to use Homebrew. If you do not want to install Homebrew or you are using other platforms that Julia supports, download the corresponding binaries. And then create a symbolic link /usr/local/bin/julia to the Julia executable. If /usr/local/bin/ is not in your $PATH, export it to your $PATH. Some clusters, like Habanero, Comet, or Expanse, already have Julia installed as a module, you may just module load julia to use it. If not, either install by yourself or contact your administrator.","category":"page"},{"location":"troubleshooting/#Have-trouble-installing-[PyCall.jl](https://github.com/JuliaPy/PyCall.jl)","page":"Troubleshooting","title":"Have trouble installing PyCall.jl","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you are seeing error message like this:","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"ERROR: LoadError: InitError: PyError (PyImport_ImportModule\n\nThe Python package qha could not be imported by pyimport. Usually this means\nthat you did not install qha in the Python version being used by PyCall.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"One solution is to re-configure PyCall to use a different Python version on your system: set ENV[\"PYTHON\"] to the path of the python executable you want to use, run Pkg.build(\"PyCall\"), and re-launch Julia. Please see this part for more detailed instructions.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Another solution is to configure PyCall to use a Julia-specific Python distribution via the Conda.jl package (which installs a private Anaconda Python distribution), which has the advantage that packages can be installed and kept up-to-date via Julia.  As explained in the PyCall documentation, in Julia, set ENV[\"PYTHON\"]=\"\", run Pkg.build(\"PyCall\"), and re-launch Julia.","category":"page"},{"location":"troubleshooting/#Loading-settings","page":"Troubleshooting","title":"Loading settings","text":"","category":"section"},{"location":"troubleshooting/#Error-parsing-YAML-files","page":"Troubleshooting","title":"Error parsing YAML files","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you encounter","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"ERROR: expected '<document start>' but found YAML.BlockMappingStartToken at nothing","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"or","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"ERROR: while scanning a simple key at line n, column 0: could not find expected ':' at line n+1, column 0","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"Check whether you have no space between the YAML key and its value like key:1 or key:some text, etc. To correct, change to key: 1, key: some text, etc. Otherwise check other YAML syntax you may have broken.","category":"page"},{"location":"troubleshooting/#Loading-Express","page":"Troubleshooting","title":"Loading Express","text":"","category":"section"},{"location":"troubleshooting/#Why-is-Julia-compiling/loading-modules-so-slow?-What-can-I-do?","page":"Troubleshooting","title":"Why is Julia compiling/loading modules so slow? What can I do?","text":"","category":"section"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"First, we recommend you download the latest version of Julia. Usually, the newest version has the best performance.","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"If you just want Julia to do a simple task and only once, you could start Julia REPL with","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"$ julia --compile=min","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"to minimize compilation or","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"$ julia --optimize=0","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"to minimize optimizations, or just use both. Or you could make a system image and run with","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"$ julia --sysimage custom-image.so","category":"page"},{"location":"troubleshooting/","page":"Troubleshooting","title":"Troubleshooting","text":"See Fredrik Ekre's talk for details.","category":"page"},{"location":"install/#Installation","page":"Installation","title":"Installation","text":"","category":"section"},{"location":"install/#Install-Julia","page":"Installation","title":"Install Julia","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"First, you should install Julia. We recommend downloading it from its official website. Versions higher than v1.3, especially v1.6, are strongly recommended. This package may not work on v0.7 and below. Please follow the detailed instructions on its website if you have to build Julia from source. Some computing centers provide preinstalled Julia. Please contact your administrator for more information in that case.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If you have Homebrew installed, open Terminal.app and type","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"$ brew install --cask julia  # on macOS","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"or","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"$ brew install julia  # on other operating systems","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If you want to install multiple Julia versions in the same operating system, a suggested way is to use a version manager such as asdf. First, install asdf. Then, run","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"$ asdf install julia 1.6.4   # or other versions of Julia\n$ asdf global julia 1.6.4","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"to install Julia and set v1.6.4 as a global version.","category":"page"},{"location":"install/#Install-Express","page":"Installation","title":"Install Express","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"Now I am using macOS as a standard platform to explain the following steps:","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"Open Terminal.app, and type julia to start an interactive session (known as REPL).\nRun the following commands and wait for them to finish:\njulia> using Pkg; Pkg.update()\n\njulia> Pkg.add(\"Express\")\nRun\njulia> using Express\nand have fun!\nWhile using, please keep this Julia session alive. Restarting might recompile the package and cost some time.","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"If you want to install the latest in development (maybe buggy) version of Express, type","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"julia> using Pkg; Pkg.update()\n\njulia> pkg\"add Express#master\"","category":"page"},{"location":"install/","page":"Installation","title":"Installation","text":"in the second step instead.","category":"page"},{"location":"install/#Uninstall-and-reinstall-Express","page":"Installation","title":"Uninstall and reinstall Express","text":"","category":"section"},{"location":"install/","page":"Installation","title":"Installation","text":"To uninstall, in a Julia session, run\njulia> Pkg.rm(\"Express\"); Pkg.gc()\nPress ctrl+d to quit the current session. Start a new Julia session and reinstall Express.","category":"page"},{"location":"api/EquationOfStateWorkflow/#Express.EquationOfStateWorkflow-module","page":"EquationOfStateWorkflow module","title":"Express.EquationOfStateWorkflow module","text":"","category":"section"},{"location":"api/EquationOfStateWorkflow/","page":"EquationOfStateWorkflow module","title":"EquationOfStateWorkflow module","text":"Modules = [Express.EquationOfStateWorkflow]","category":"page"},{"location":"configuration/#Configuration-files","page":"Configuration files","title":"Configuration files","text":"","category":"section"},{"location":"configuration/","page":"Configuration files","title":"Configuration files","text":"Express can be run from a configuration file, with some preset rules. The following sections introduce how to write such configuration files. By now, only YAML, JSON, and TOML formats are supported. Please refer their official documentation for their syntax. In the examples below, we will use YAML syntax for configuration files. But for readability purposes, we suggest users use the TOML syntax.","category":"page"},{"location":"configuration/#Fitting-equations-of-state","page":"Configuration files","title":"Fitting equations of state","text":"","category":"section"},{"location":"configuration/","page":"Configuration files","title":"Configuration files","text":"The configuration file for the EOS workflow has the following syntax:","category":"page"},{"location":"configuration/","page":"Configuration files","title":"Configuration files","text":"recipe: A string that represents the type of the workflow. Allowed value is eos.\ntemplate: The path to a template input file for a specific software. It should be on the same file system where express is deployed.\ntrial_eos: The trial EOS contains initial values for input files generation and EOS fitting.\ntype: A string that represents the type of the EOS. Allowed values are murnaghan (Murnaghan), bm2 (Birch–Murnaghan second order), bm3, bm4, vinet (Vinet), pt2 (Poirier–Tarantola second order), pt3, and pt4.\nvalues: A vector of strings that specifies each value of the EOS. The default order is V_0, B_0, B_0(, B_0, etc.). Units must be provided.\nfixed:\npressures or volumes: Whether to fix pressures of volumes.\nvalues: Specify the pressures or volumes. It can be a vector of numbers, or a string with the syntax start:step:stop to form an arithmetic sequence where start, stop, and step are numbers indicating the start, the end, and the common difference of that sequence. See \"Creating arrays using range objects\" for more information.\nunit: The units of pressure or volume. The pressure and volume default units are GPa and angstrom^3. Allowed values for volumes are nm^3, angstrom^3, bohr^3, etc. Allowed values for pressures are Pa, GPa, TPa, ..., bar, kbar, ..., atm, and the combinations of eV, Ry, hartree, J, with any unit of volume.\nfiles:\ndirs: It specifies the paths of output directories.\nroot: The path of the root directory of output files.\npattern: A string specifying the naming convention of the output directories. Its default value is p=. For example, if fixed.pressures.values is a vector of pressures [10, 20, 30] which represents the relaxations are done from 10-30GPa, then the generated inputs and outputs will be stored in directories p=10, p=20 and p=30.\nsave:\nstatus: The path to a binary file that stores the status of the workflow.\neos: The path to a binary file that stores the fitted equations of state.\ncli:\nmpi: The configurations of the MPI software.\nnp: An integer indicating the number of processors/cores/CPUs used.","category":"page"},{"location":"configuration/","page":"Configuration files","title":"Configuration files","text":"The code block below shows a typical configuration file for an EOS workflow in the YAML syntax:","category":"page"},{"location":"configuration/","page":"Configuration files","title":"Configuration files","text":"recipe: eos\ncli:\n  mpi:\n    np: 16\ntemplate: template.in\nsave:\n  status: status.jls\nfixed:\n  pressures:\n    unit: GPa\n    values:\n      - -5\n      - -2\n      - 0\n      - 5\n      - 10\n      - 15\n      - 17\n      - 20\ntrial_eos:\n  type: bm3\n  values:\n    - 300.44 bohr^3\n    - 74.88 GPa\n    - 4.82","category":"page"},{"location":"configuration/","page":"Configuration files","title":"Configuration files","text":"The JSON and TOML equivalents of the above file are:","category":"page"},{"location":"configuration/","page":"Configuration files","title":"Configuration files","text":"{\n  \"recipe\": \"eos\",\n  \"cli\": {\n    \"mpi\": {\n      \"np\": 16\n    }\n  },\n  \"template\": \"template.in\",\n  \"save\": {\n    \"status\": \"status.jls\"\n  },\n  \"fixed\": {\n    \"pressures\": {\n      \"unit\": \"GPa\",\n      \"values\": [\n        -5,\n        -2,\n        0,\n        5,\n        10,\n        15,\n        17,\n        20\n      ]\n    }\n  },\n  \"trial_eos\": {\n    \"type\": \"bm3\",\n    \"values\": [\n      \"300.44 bohr^3\",\n      \"74.88 GPa\",\n      4.82\n    ]\n  }\n}","category":"page"},{"location":"configuration/","page":"Configuration files","title":"Configuration files","text":"recipe = 'eos'\ntemplate = 'template.in'\n[fixed.pressures]\nunit = 'GPa'\nvalues = [-5, -2, 0, 5, 10, 15, 17, 20]\n\n[trial_eos]\ntype = 'bm3'\nvalues = ['300.44 bohr^3', '74.88 GPa', 4.82]\n[cli.mpi]\nnp = 16\n\n[save]\nstatus = 'status.jls'","category":"page"},{"location":"configuration/#Phonon-density-of-states-or-phonon-dispersion-relation","page":"Configuration files","title":"Phonon density of states or phonon dispersion relation","text":"","category":"section"},{"location":"configuration/","page":"Configuration files","title":"Configuration files","text":"The configuration file for the phonon workflow has the following syntax:","category":"page"},{"location":"configuration/","page":"Configuration files","title":"Configuration files","text":"recipe: A string that represents the type of the workflow. Allowed values are phonon dispersion (phonon dispersion along a q-path) and vdos (phonon density of states).\ntemplate:\nscf: The path to a template input file for an SCF calculation.\ndfpt: The path to a template input file for a DFPT calculation.\nq2r: The path to a template input file for a Fourier transform.\ndisp: The path to a template input file for a phonon dispersion/phonon density of states calculation.\nfixed:\npressures or volumes: Whether to fix pressures of volumes.\nvalues: Specify the pressures or volumes. It can be a vector of numbers, or a string with the syntax start:step:stop to form an arithmetic sequence where start, stop, and step are numbers indicating the start, the end, and the common difference of that sequence. See \"Creating arrays using range objects\" for more information.\nunit: The units of pressure or volume. The pressure and volume default units are GPa and angstrom^3. Allowed values for volumes are nm^3, angstrom^3, bohr^3, etc. Allowed values for pressures are Pa, GPa, TPa, ..., bar, kbar, ..., atm, and the combinations of eV, Ry, hartree, J, with any unit of volume.\nfiles:\ndirs: It specifies the paths of output directories.\nroot: The path of the root directory of output files.\npattern: A string specifying the naming convention of the output directories. Its default value is p=. For example, if fixed.pressures.values is a vector of pressures [10, 20, 30] which represents the relaxations are done from 10-30GPa, then the generated inputs and outputs will be stored in directories p=10, p=20 and p=30.\nsave:\nstatus: The path to a binary file that stores the status of the workflow.\ncli:\nmpi: The configurations of the MPI software.\nnp: An integer indicating the number of processors/cores/CPUs used.","category":"page"},{"location":"configuration/","page":"Configuration files","title":"Configuration files","text":"The code block below shows a typical configuration file for a phonon workflow in the YAML syntax:","category":"page"},{"location":"configuration/","page":"Configuration files","title":"Configuration files","text":"recipe: vdos\ncli:\n  mpi:\n    np: 16\ntemplate:\n  scf: template.in\n  dfpt: ph.in\n  q2r: q2r.in\n  disp: disp.in\nsave:\n  status: status.jls\nfixed:\n  pressures:\n    unit: GPa\n    values:\n      - -5\n      - -2\n      - 0\n      - 5\n      - 10\n      - 15\n      - 17\n      - 20","category":"page"},{"location":"configuration/","page":"Configuration files","title":"Configuration files","text":"The JSON and TOML equivalents of the above file are:","category":"page"},{"location":"configuration/","page":"Configuration files","title":"Configuration files","text":"{\n  \"recipe\": \"vdos\",\n  \"cli\": {\n    \"mpi\": {\n      \"np\": 16\n    }\n  },\n  \"template\": {\n    \"scf\": \"template.in\",\n    \"dfpt\": \"ph.in\",\n    \"q2r\": \"q2r.in\",\n    \"disp\": \"disp.in\"\n  },\n  \"save\": {\n    \"status\": \"status.jls\"\n  },\n  \"fixed\": {\n    \"pressures\": {\n      \"unit\": \"GPa\",\n      \"values\": [\n        -5,\n        -2,\n        0,\n        5,\n        10,\n        15,\n        17,\n        20\n      ]\n    }\n  }\n}","category":"page"},{"location":"configuration/","page":"Configuration files","title":"Configuration files","text":"recipe = 'vdos'\n[cli.mpi]\nnp = 16\n\n[template]\ndfpt = 'ph.in'\ndisp = 'disp.in'\nq2r = 'q2r.in'\nscf = 'template.in'\n[fixed.pressures]\nunit = 'GPa'\nvalues = [-5, -2, 0, 5, 10, 15, 17, 20]\n\n[save]\nstatus = 'status.jls'","category":"page"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = Express","category":"page"},{"location":"#Express","page":"Home","title":"Express","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Documentation for Express.","category":"page"},{"location":"#Package-Features","page":"Home","title":"Package Features","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Express is an extensible, high-throughput, high-level workflow framework that aims to automate ab initio calculations for the materials science community. Express is shipped with well-tested workflow templates, including structure optimization, equation of state (EOS) fitting, phonon spectrum (lattice dynamics) calculation, and thermodynamic property calculation in the framework of the quasi-harmonic approximation (QHA). It is designed to be highly modularized so that its components can be reused across various occasions, and customized workflows can be built on top of that.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The differences between express and Express: express is the project's name, it is a collection of Julia packages. Its core is Express.jl, managing and dispatching the rest packages. Express is short for Express.jl, which is the most important component of express. The direct components of express are:","category":"page"},{"location":"","page":"Home","title":"Home","text":"(Image: components)","category":"page"},{"location":"","page":"Home","title":"Home","text":"Express.jl provides a high-level interface to all the workflows, including file reading and writing, job creation, submission, monitoring, result retrieving, and data analysis. To work with specific software, install the corresponding plugin, e.g., QuantumESPRESSOExpress.jl for Quantum ESPRESSO.\nExpressCommands.jl is a user-friendly command-line interface of Express.jl for non-developers. It installs an executable 'xps' that can execute code from configuration files provided by users.\nEquationsOfStateOfSolids.jl fits energy (or pressure) vs. volume results to equations of state, etc. These features are repetitively used in the equation of state workflow.\nCrystallography.jl calculates a crystal's primitive cell (or supercell) volume from lattice parameters, finds symmetry operations and generates high symmetry points in the Brillouin zone, etc.\nPyQHA.jl is a Julia wrapper of the Python qha package, which can calculate several thermodynamic properties of both single- and multi-configuration crystalline materials in the framework of quasi-harmonic approximation (QHA). The qha code is the foundation of the QHA workflow.\nGeotherm.jl is a Julia interpretation of the Fortran code we used in this paper, which calculates the isentropic temperature/pressure gradient (geotherm) using thermodynamic properties obtained with the QHA workflow.\nPseudopotentials.jl presents a database for storing and querying pseudopotentials used in ab initio calculations.\nSimpleWorkflows.jl is the skeleton of the workflow system, which defines building blocks, composition rules, and operation order of workflows.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The QuantumESPRESSOExpress.jl is a special type of package called \"plugin of express\" for handling ab initio software such as Quantum ESPRESSO. Other plugins for other software are possible. The dependencies of QuantumESPRESSOExpress.jl are listed below.","category":"page"},{"location":"","page":"Home","title":"Home","text":"AbInitioSoftwareBase.jl provides a standard API for some popular ab initio software such as Quantum ESPRESSO.\nQuantumESPRESSOBase.jl declares basic data types and methods for manipulating crystal structures, generating input files for Quantum ESPRESSO, error checking before running, etc.\nQuantumESPRESSOParser.jl parses the input or output files of Quantum ESPRESSO to extract and analyze data.\nQuantumESPRESSOFormatter.jl formats the input files of Quantum ESPRESSO.\nQuantumESPRESSOCommands.jl is a command-line interface that exports the commands Quantum ESPRESSO uses in a configurable way.\nQuantumESPRESSO.jl is simply a wrapper of the types, methods, and commands defined in QuantumESPRESSOBase.jl, QuantumESPRESSOParser.jl, QuantumESPRESSOFormatter.jl, and QuantumESPRESSOCommands.jl under a common namespace.","category":"page"},{"location":"#Manual-Outline","page":"Home","title":"Manual Outline","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"Pages = [\n    \"install.md\",\n    \"develop.md\",\n    \"configuration.md\",\n    \"troubleshooting.md\",\n    \"api/EquationOfStateWorkflow.md\",\n]\nDepth = 3","category":"page"},{"location":"#main-index","page":"Home","title":"Index","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"","category":"page"},{"location":"questions/#Some-other-questions-about-Express","page":"Other questions","title":"Some other questions about Express","text":"","category":"section"},{"location":"questions/#What-is-the-difference-between-Express-and-express?","page":"Other questions","title":"What is the difference between Express and express?","text":"","category":"section"},{"location":"questions/","page":"Other questions","title":"Other questions","text":"express is the workflow framework's name, while Express is the short form of Express.jl, the Julia implementation of express. We do not want the project's name linked to a specific programming language: who says we cannot have a Python version of express in the future?","category":"page"},{"location":"questions/#Why-do-you-use-Julia,-why-not-use...?","page":"Other questions","title":"Why do you use Julia, why not use...?","text":"","category":"section"},{"location":"questions/","page":"Other questions","title":"Other questions","text":"The same as the Julia's \"we are greedy\" speech:","category":"page"},{"location":"questions/","page":"Other questions","title":"Other questions","text":"We are greedy: we want more.We want a language that's open source, with a liberal license. We want the speed of C with the dynamism of Ruby. We want a language that's homoiconic, with true macros like Lisp, but with obvious, familiar mathematical notation like Matlab. We want something as usable for general programming as Python, as easy for statistics as R, as natural for string processing as Perl, as powerful for linear algebra as Matlab, as good at gluing programs together as the shell. Something that is dirt simple to learn, yet keeps the most serious hackers happy. We want it interactive and we want it compiled.","category":"page"},{"location":"questions/","page":"Other questions","title":"Other questions","text":"To summarize,","category":"page"},{"location":"questions/","page":"Other questions","title":"Other questions","text":"we want the code as easy to read/write as Python, but as fast as C;\nwe want the code as extensible as possible;\nwe want the flourishing ecosystem of Julia, dedicated to and developed by the scientific community itself.","category":"page"},{"location":"questions/#Why-do-you-create-express,-given-that-[AiiDA](https://www.aiida.net/),-[ASE](https://gitlab.com/ase/ase),-[atomate](https://atomate.org/),-etc.,-are-already-there?","page":"Other questions","title":"Why do you create express, given that AiiDA, ASE, atomate, etc., are already there?","text":"","category":"section"},{"location":"questions/","page":"Other questions","title":"Other questions","text":"Good question. The short answer is: we are never satisfied.","category":"page"},{"location":"questions/","page":"Other questions","title":"Other questions","text":"Those projects are of very high quality and are de facto standards of the materials simulation community. They have much larger teams and longer history than us, so it is unrealistic to say we are better than them in every aspect in the first few releases of express. However, it does not mean we cannot have our features or advantages. Our code has higher extensibility, modularity, and readability.","category":"page"},{"location":"questions/","page":"Other questions","title":"Other questions","text":"As explained in the paper, express is a highly modularized collection of packages. Each of them provides a succinct but complete set of functionalities that is repeatedly used in materials modeling. Even without other packages, each of them can still solve its dedicated questions. We faithfully follow the Unix philosophy","category":"page"},{"location":"questions/","page":"Other questions","title":"Other questions","text":"Write programs that do one thing and do it well. Write programs to work together.","category":"page"},{"location":"questions/","page":"Other questions","title":"Other questions","text":"when developing express. For example, Pseudopotentials.jl, Crystallography.jl, EquationsOfStateOfSolids.jl, QuantumESPRESSO.jl, etc., are distinct packages. They can work together to form the equation of state workflow, and they can also be used separately if users want to use specific features, e.g., managing pseudopotentials, calculating structural symmetry, fitting existing data. In that case, only related code will be installed, which saves disk space and time. However, most code in, for instance, aiida-core, is dealing with servers, network, databases, web interfaces, YAML, etc, which makes it a gigantic project that is hard to read, trace, and debug. And everything in AiiDA is bond to its workflow system. Its data structure may not be compatible with other people's code. It is difficult for users who are unfamiliar with their code structure to pick a subset of features they need if they want to customize. In express, everything is very loosely coupled to each other, no workflow needs to be composed if you just want to do a simple thing (In fact, each workflow in express is just a collection of predefined wrappers of functions that its dependencies have already provided. The core code of Express.jl is very small.). Users can cooperate with others' packages with little effort thanks to the composability that Julia enables. For example, in express, our users never need to convert units. With the help of Julia's Unitful.jl package, users can always throw literal units they obtained from experiments or papers directly to express and do not need to consider whether they are compatible or not. This is helpful when fitting equations of state, modifying crystal structures, etc. From developers' side, we seldom need to adapt for others' code. Theirs and ours just \"magically\" work together. You usually do not have such flexibility in other languages. Besides, even the core calculation part of AiiDA and atomate, they use pymatgen, another phenomenal code in the materials science community. However, it is still an enormous code that integrates too many things together, which limits its extensibility.","category":"page"}]
}
