<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Design Principles · Express.jl</title><script data-outdated-warner src="../../assets/warner.js"></script><link rel="canonical" href="https://MineralsCloud.github.io/Express.jl/developers/design-principles/"/><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.045/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.4/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.24/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL="../.."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../../assets/documenter.js"></script><script src="../../siteinfo.js"></script><script src="../../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../../"><img src="../../assets/logo.png" alt="Express.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../../">Express.jl</a></span></div><form class="docs-search" action="../../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../../installation/">Installation guide</a></li><li><input class="collapse-toggle" id="menuitem-2-2" type="checkbox"/><label class="tocitem" for="menuitem-2-2"><span class="docs-label">Running</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../../run/configuration/">Configuration files</a></li><li><a class="tocitem" href="../../run/cli/">How to run <code>Express</code> from command line</a></li><li><a class="tocitem" href="../../run/jobs/">Tracking and monitoring jobs in a workflow</a></li></ul></li></ul></li><li><span class="tocitem">Developer Docs</span><ul><li><a class="tocitem" href="../contributing/">Contributing</a></li><li><a class="tocitem" href="../style-guide/">Style Guide</a></li><li class="is-active"><a class="tocitem" href>Design Principles</a><ul class="internal"><li><a class="tocitem" href="#Consistency-vs-adherence"><span>Consistency vs adherence</span></a></li><li><a class="tocitem" href="#Community-contribution-guidelines"><span>Community contribution guidelines</span></a></li><li><a class="tocitem" href="#Open-source-contributions-are-allowed-to-start-small-and-grow-over-time"><span>Open source contributions are allowed to start small and grow over time</span></a></li><li><a class="tocitem" href="#Generic-code-is-preferred-unless-code-is-known-to-be-specific"><span>Generic code is preferred unless code is known to be specific</span></a></li><li><a class="tocitem" href="#Internal-types-should-match-the-types-used-by-users-when-possible"><span>Internal types should match the types used by users when possible</span></a></li><li><a class="tocitem" href="#Trait-definition-and-adherence-to-generic-interface-is-preferred-when-possible"><span>Trait definition and adherence to generic interface is preferred when possible</span></a></li><li><a class="tocitem" href="#Macros-should-be-limited-and-only-be-used-for-syntactic-sugar"><span>Macros should be limited and only be used for syntactic sugar</span></a></li><li><a class="tocitem" href="#Errors-should-be-caught-as-high-as-possible,-and-error-messages-should-be-contextualized-for-newcomers"><span>Errors should be caught as high as possible, and error messages should be contextualized for newcomers</span></a></li><li><a class="tocitem" href="#Subpackaging-and-interface-packages-is-preferred-over-conditional-modules-via-Requires.jl"><span>Subpackaging and interface packages is preferred over conditional modules via Requires.jl</span></a></li><li><a class="tocitem" href="#Functions-should-either-attempt-to-be-non-allocating-and-reuse-caches,-or-treat-inputs-as-immutable"><span>Functions should either attempt to be non-allocating and reuse caches, or treat inputs as immutable</span></a></li><li><a class="tocitem" href="#Out-of-place-and-immutability-is-preferred-when-sufficient-performant"><span>Out-of-place and immutability is preferred when sufficient performant</span></a></li><li><a class="tocitem" href="#Tests-should-attempt-to-cover-a-wide-gamut-of-input-types"><span>Tests should attempt to cover a wide gamut of input types</span></a></li><li><a class="tocitem" href="#When-in-doubt,-a-submodule-should-become-a-subpackage-or-separate-package"><span>When in doubt, a submodule should become a subpackage or separate package</span></a></li><li><a class="tocitem" href="#Globals-should-be-avoided-whenever-possible"><span>Globals should be avoided whenever possible</span></a></li><li><a class="tocitem" href="#Type-stable-and-type-grounded-code-is-preferred-wherever-possible"><span>Type-stable and type-grounded code is preferred wherever possible</span></a></li><li><a class="tocitem" href="#Closures-should-be-avoided-whenever-possible"><span>Closures should be avoided whenever possible</span></a></li><li><a class="tocitem" href="#Numerical-functionality-should-use-the-appropriate-generic-numerical-interfaces"><span>Numerical functionality should use the appropriate generic numerical interfaces</span></a></li><li><a class="tocitem" href="#Functions-should-capture-one-underlying-principle"><span>Functions should capture one underlying principle</span></a></li><li><a class="tocitem" href="#Internal-choices-should-be-exposed-as-options-whenever-possible"><span>Internal choices should be exposed as options whenever possible</span></a></li><li><a class="tocitem" href="#Prefer-code-reuse-over-rewrites-whenever-possible"><span>Prefer code reuse over rewrites whenever possible</span></a></li><li><a class="tocitem" href="#Prefer-to-not-shadow-functions"><span>Prefer to not shadow functions</span></a></li></ul></li></ul></li><li><a class="tocitem" href="../../troubleshooting/">Troubleshooting</a></li><li><a class="tocitem" href="../../faq/">FAQ</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Developer Docs</a></li><li class="is-active"><a href>Design Principles</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Design Principles</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/MineralsCloud/Express.jl/blob/main/docs/src/developers/design-principles.md#" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Design-Principles"><a class="docs-heading-anchor" href="#Design-Principles">Design Principles</a><a id="Design-Principles-1"></a><a class="docs-heading-anchor-permalink" href="#Design-Principles" title="Permalink"></a></h1><ul><li><a href="#Design-Principles">Design Principles</a></li><li class="no-marker"><ul><li><a href="#Consistency-vs-adherence">Consistency vs adherence</a></li><li><a href="#Community-contribution-guidelines">Community contribution guidelines</a></li><li><a href="#Open-source-contributions-are-allowed-to-start-small-and-grow-over-time">Open source contributions are allowed to start small and grow over time</a></li><li><a href="#Generic-code-is-preferred-unless-code-is-known-to-be-specific">Generic code is preferred unless code is known to be specific</a></li><li><a href="#Internal-types-should-match-the-types-used-by-users-when-possible">Internal types should match the types used by users when possible</a></li><li><a href="#Trait-definition-and-adherence-to-generic-interface-is-preferred-when-possible">Trait definition and adherence to generic interface is preferred when possible</a></li><li><a href="#Macros-should-be-limited-and-only-be-used-for-syntactic-sugar">Macros should be limited and only be used for syntactic sugar</a></li><li><a href="#Errors-should-be-caught-as-high-as-possible,-and-error-messages-should-be-contextualized-for-newcomers">Errors should be caught as high as possible, and error messages should be contextualized for newcomers</a></li><li><a href="#Subpackaging-and-interface-packages-is-preferred-over-conditional-modules-via-Requires.jl">Subpackaging and interface packages is preferred over conditional modules via Requires.jl</a></li><li><a href="#Functions-should-either-attempt-to-be-non-allocating-and-reuse-caches,-or-treat-inputs-as-immutable">Functions should either attempt to be non-allocating and reuse caches, or treat inputs as immutable</a></li><li><a href="#Out-of-place-and-immutability-is-preferred-when-sufficient-performant">Out-of-place and immutability is preferred when sufficient performant</a></li><li><a href="#Tests-should-attempt-to-cover-a-wide-gamut-of-input-types">Tests should attempt to cover a wide gamut of input types</a></li><li><a href="#When-in-doubt,-a-submodule-should-become-a-subpackage-or-separate-package">When in doubt, a submodule should become a subpackage or separate package</a></li><li><a href="#Globals-should-be-avoided-whenever-possible">Globals should be avoided whenever possible</a></li><li><a href="#Type-stable-and-type-grounded-code-is-preferred-wherever-possible">Type-stable and type-grounded code is preferred wherever possible</a></li><li><a href="#Closures-should-be-avoided-whenever-possible">Closures should be avoided whenever possible</a></li><li><a href="#Numerical-functionality-should-use-the-appropriate-generic-numerical-interfaces">Numerical functionality should use the appropriate generic numerical interfaces</a></li><li><a href="#Functions-should-capture-one-underlying-principle">Functions should capture one underlying principle</a></li><li><a href="#Internal-choices-should-be-exposed-as-options-whenever-possible">Internal choices should be exposed as options whenever possible</a></li><li><a href="#Prefer-code-reuse-over-rewrites-whenever-possible">Prefer code reuse over rewrites whenever possible</a></li><li><a href="#Prefer-to-not-shadow-functions">Prefer to not shadow functions</a></li></ul></li></ul><p>We adopt some <a href="https://sciml.ai/"><code>SciML</code></a> design <a href="https://github.com/SciML/SciMLStyle">guidelines</a> here. Please read it before contributing!</p><h2 id="Consistency-vs-adherence"><a class="docs-heading-anchor" href="#Consistency-vs-adherence">Consistency vs adherence</a><a id="Consistency-vs-adherence-1"></a><a class="docs-heading-anchor-permalink" href="#Consistency-vs-adherence" title="Permalink"></a></h2><p>According to PEP8:</p><blockquote><p>A style guide is about consistency. Consistency with this style guide is important. Consistency within a project is more important. Consistency within one module or function is the most important.</p><p>However, know when to be inconsistent—sometimes style guide recommendations just aren&#39;t applicable. When in doubt, use your best judgment. Look at other examples and decide what looks best. And don’t hesitate to ask!</p></blockquote><h2 id="Community-contribution-guidelines"><a class="docs-heading-anchor" href="#Community-contribution-guidelines">Community contribution guidelines</a><a id="Community-contribution-guidelines-1"></a><a class="docs-heading-anchor-permalink" href="#Community-contribution-guidelines" title="Permalink"></a></h2><p>For a comprehensive set of community contribution guidelines, refer to <a href="https://github.com/SciML/ColPrac">ColPrac</a>. A relevant point to highlight PRs should do one thing. In the context of style, this means that PRs which update the style of a package&#39;s code should not be mixed with fundamental code contributions. This separation makes it easier to ensure that large style improvement are isolated from substantive (and potentially breaking) code changes.</p><h2 id="Open-source-contributions-are-allowed-to-start-small-and-grow-over-time"><a class="docs-heading-anchor" href="#Open-source-contributions-are-allowed-to-start-small-and-grow-over-time">Open source contributions are allowed to start small and grow over time</a><a id="Open-source-contributions-are-allowed-to-start-small-and-grow-over-time-1"></a><a class="docs-heading-anchor-permalink" href="#Open-source-contributions-are-allowed-to-start-small-and-grow-over-time" title="Permalink"></a></h2><p>If the standard for code contributions is that every PR needs to support every possible input type that anyone can think of, the barrier would be too high for newcomers. Instead, the principle is to be as correct as possible to begin with, and grow the generic support over time. All recommended functionality should be tested, any known generality issues should be documented in an issue (and with a <code>@test_broken</code> test when possible).</p><h2 id="Generic-code-is-preferred-unless-code-is-known-to-be-specific"><a class="docs-heading-anchor" href="#Generic-code-is-preferred-unless-code-is-known-to-be-specific">Generic code is preferred unless code is known to be specific</a><a id="Generic-code-is-preferred-unless-code-is-known-to-be-specific-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-code-is-preferred-unless-code-is-known-to-be-specific" title="Permalink"></a></h2><p>For example, the code:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f(A, B)
           for i in 1:length(A)
               A[i] = A[i] + B[i]
           end
       end</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code></pre><p>would not be preferred for two reasons. One is that it assumes <code>A</code> uses one-based indexing, which would fail in cases like <a href="https://github.com/JuliaArrays/OffsetArrays.jl">OffsetArrays</a> and <a href="https://github.com/JuliaArrays/FFTViews.jl">FFTViews</a>. Another issue is that it requires indexing, while not all array types support indexing (for example, <a href="https://github.com/JuliaGPU/CuArrays.jl">CuArrays</a>). A more generic compatible implementation of this function would be to use broadcast, for example:</p><pre><code class="language-julia-repl hljs" style="display:block;">julia&gt; function f(A, B)
           @. A = A + B
       end</code><code class="nohighlight hljs ansi" style="display:block;">f (generic function with 1 method)</code></pre><p>which would allow support for a wider variety of array types.</p><h2 id="Internal-types-should-match-the-types-used-by-users-when-possible"><a class="docs-heading-anchor" href="#Internal-types-should-match-the-types-used-by-users-when-possible">Internal types should match the types used by users when possible</a><a id="Internal-types-should-match-the-types-used-by-users-when-possible-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-types-should-match-the-types-used-by-users-when-possible" title="Permalink"></a></h2><p>If <code>f(A)</code> takes the input of some collections and computes an output from those collections, then it should be expected that if the user gives <code>A</code> as an <code>Array</code>, the computation should be done via <code>Array</code>s. If <code>A</code> was a <code>CuArray</code>, then it should be expected that the computation should be internally done using a <code>CuArray</code> (or appropriately error if not supported). For these reasons, constructing arrays via generic methods, like <code>similar(A)</code>, is preferred when writing <code>f</code> instead of using non-generic constructors like <code>Array(undef,size(A))</code> unless the function is documented as being non-generic.</p><h2 id="Trait-definition-and-adherence-to-generic-interface-is-preferred-when-possible"><a class="docs-heading-anchor" href="#Trait-definition-and-adherence-to-generic-interface-is-preferred-when-possible">Trait definition and adherence to generic interface is preferred when possible</a><a id="Trait-definition-and-adherence-to-generic-interface-is-preferred-when-possible-1"></a><a class="docs-heading-anchor-permalink" href="#Trait-definition-and-adherence-to-generic-interface-is-preferred-when-possible" title="Permalink"></a></h2><p>Julia provides many interfaces, for example:</p><ul><li><a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interface-iteration">Iteration</a></li><li><a href="https://docs.julialang.org/en/v1/manual/interfaces/#Indexing">Indexing</a></li><li><a href="https://docs.julialang.org/en/v1/manual/interfaces/#man-interfaces-broadcasting">Broadcast</a></li></ul><p>Those interfaces should be followed when possible. For example, when defining broadcast overloads, one should implement a <code>BroadcastStyle</code> as suggested by the documentation instead of simply attempting to bypass the broadcast system via <code>copyto!</code> overloads.</p><p>When interface functions are missing, these should be added to Base Julia or an interface package, like <a href="https://github.com/JuliaArrays/ArrayInterface.jl">ArrayInterface.jl</a>. Such traits should be declared and used when appropriate. For example, if a line of code requires mutation, the trait <code>ArrayInterface.ismutable(A)</code> should be checked before attempting to mutate, and informative error messages should be written to capture the immutable case (or, an alternative code which does not mutate should be given).</p><p>One example of this principle is demonstrated in the generation of Jacobian matrices. In many scientific applications, one may wish to generate a Jacobian cache from the user&#39;s input <code>u0</code>. A naive way to generate this Jacobian is <code>J = similar(u0,length(u0),length(u0))</code>. However, this will generate a Jacobian <code>J</code> such that <code>J isa Matrix</code>.</p><h2 id="Macros-should-be-limited-and-only-be-used-for-syntactic-sugar"><a class="docs-heading-anchor" href="#Macros-should-be-limited-and-only-be-used-for-syntactic-sugar">Macros should be limited and only be used for syntactic sugar</a><a id="Macros-should-be-limited-and-only-be-used-for-syntactic-sugar-1"></a><a class="docs-heading-anchor-permalink" href="#Macros-should-be-limited-and-only-be-used-for-syntactic-sugar" title="Permalink"></a></h2><p>Macros define new syntax, and for this reason they tend to be less composable than other coding styles and require prior familiarity to be easily understood. One principle to keep in mind is, &quot;can the person reading the code easily picture what code is being generated?&quot;. For example, a user of Soss.jl may not know what code is being generated by:</p><pre><code class="language-julia hljs">@model (x, α) begin
    σ ~ Exponential()
    β ~ Normal()
    y ~ For(x) do xj
        Normal(α + β * xj, σ)
    end
    return y
end</code></pre><p>and thus using such a macro as the interface is not preferred when possible. However, a macro like <a href="https://github.com/SciML/MuladdMacro.jl"><code>@muladd</code></a> is trivial to picture on a code (it recursively transforms <code>a*b + c</code> to <code>muladd(a,b,c)</code> for more <a href="https://en.wikipedia.org/wiki/Multiply%E2%80%93accumulate_operation">accuracy and efficiency</a>), so using such a macro for example:</p><pre><code class="language-julia hljs">julia&gt; @macroexpand(@muladd k3 = f(t + c3 * dt, @. uprev + dt * (a031 * k1 + a032 * k2)))
:(k3 = f((muladd)(c3, dt, t), (muladd).(dt, (muladd).(a032, k2, (*).(a031, k1)), uprev)))</code></pre><p>is recommended. Some macros in this category are:</p><ul><li><code>@inbounds</code></li><li><a href="https://github.com/SciML/MuladdMacro.jl"><code>@muladd</code></a></li><li><code>@view</code></li><li><a href="https://github.com/SciML/ModelingToolkit.jl"><code>@named</code></a></li><li><code>@.</code></li><li><a href="https://github.com/YingboMa/FastBroadcast.jl"><code>@..</code></a></li></ul><p>Some performance macros, like <code>@simd</code>, <code>@threads</code>, or <a href="https://github.com/JuliaSIMD/LoopVectorization.jl"><code>@turbo</code> from LoopVectorization.jl</a>, make an exception in that their generated code may be foreign to many users. However, they still are classified as appropriate uses as they are syntactic sugar since they do (or should) not change the behavior of the program in measurable ways other than performance.</p><h2 id="Errors-should-be-caught-as-high-as-possible,-and-error-messages-should-be-contextualized-for-newcomers"><a class="docs-heading-anchor" href="#Errors-should-be-caught-as-high-as-possible,-and-error-messages-should-be-contextualized-for-newcomers">Errors should be caught as high as possible, and error messages should be contextualized for newcomers</a><a id="Errors-should-be-caught-as-high-as-possible,-and-error-messages-should-be-contextualized-for-newcomers-1"></a><a class="docs-heading-anchor-permalink" href="#Errors-should-be-caught-as-high-as-possible,-and-error-messages-should-be-contextualized-for-newcomers" title="Permalink"></a></h2><p>Whenever possible, defensive programming should be used to check for potential errors before they are encountered deeper within a package. For example, if one knows that <code>f(u0,p)</code> will error unless <code>u0</code> is the size of <code>p</code>, this should be caught at the start of the function to throw a domain specific error, for example &quot;parameters and initial condition should be the same size&quot;.</p><h2 id="Subpackaging-and-interface-packages-is-preferred-over-conditional-modules-via-Requires.jl"><a class="docs-heading-anchor" href="#Subpackaging-and-interface-packages-is-preferred-over-conditional-modules-via-Requires.jl">Subpackaging and interface packages is preferred over conditional modules via Requires.jl</a><a id="Subpackaging-and-interface-packages-is-preferred-over-conditional-modules-via-Requires.jl-1"></a><a class="docs-heading-anchor-permalink" href="#Subpackaging-and-interface-packages-is-preferred-over-conditional-modules-via-Requires.jl" title="Permalink"></a></h2><p>Requires.jl should be avoided at all costs. If an interface package exists, such as <a href="https://github.com/JuliaDiff/ChainRulesCore.jl">ChainRulesCore.jl</a> for defining automatic differentiation rules without requiring a dependency on the whole ChainRules.jl system, or <a href="https://github.com/JuliaPlots/RecipesBase.jl">RecipesBase.jl</a> which allows for defining Plots.jl plot recipes without a dependency on Plots.jl, a direct dependency on these interface packages is preferred.</p><p>Otherwise, instead of resorting to a conditional dependency using Requires.jl, it is preferred one creates subpackages, i.e. smaller independent packages kept within the same Github repository with independent versioning and package management. An example of this is seen in <a href="https://github.com/SciML/Optimization.jl">Optimization.jl</a> which has subpackages like <a href="https://github.com/SciML/Optimization.jl/tree/master/lib/OptimizationBBO">OptimizationBBO.jl</a> for BlackBoxOptim.jl support.</p><p>Some important interface packages to know about are:</p><ul><li><a href="https://github.com/JuliaDiff/ChainRulesCore.jl">ChainRulesCore.jl</a></li><li><a href="https://github.com/JuliaPlots/RecipesBase.jl">RecipesBase.jl</a></li><li><a href="https://github.com/JuliaArrays/ArrayInterface.jl">ArrayInterface.jl</a></li><li><a href="https://github.com/SciML/CommonSolve.jl">CommonSolve.jl</a></li><li><a href="https://github.com/SciML/SciMLBase.jl">SciMLBase.jl</a></li></ul><h2 id="Functions-should-either-attempt-to-be-non-allocating-and-reuse-caches,-or-treat-inputs-as-immutable"><a class="docs-heading-anchor" href="#Functions-should-either-attempt-to-be-non-allocating-and-reuse-caches,-or-treat-inputs-as-immutable">Functions should either attempt to be non-allocating and reuse caches, or treat inputs as immutable</a><a id="Functions-should-either-attempt-to-be-non-allocating-and-reuse-caches,-or-treat-inputs-as-immutable-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-should-either-attempt-to-be-non-allocating-and-reuse-caches,-or-treat-inputs-as-immutable" title="Permalink"></a></h2><p>Mutating codes and non-mutating codes fall into different worlds. When a code is fully immutable, the compiler can better reason about dependencies, optimize the code, and check for correctness. However, many times a code making the fullest use of mutation can outperform even what the best compilers of today can generate. That said, the worst of all worlds is when code mixes mutation with non-mutating code. Not only is this a mishmash of coding styles, it has the potential non-locality and compiler proof issues of mutating code while not fully benefiting from the mutation.</p><h2 id="Out-of-place-and-immutability-is-preferred-when-sufficient-performant"><a class="docs-heading-anchor" href="#Out-of-place-and-immutability-is-preferred-when-sufficient-performant">Out-of-place and immutability is preferred when sufficient performant</a><a id="Out-of-place-and-immutability-is-preferred-when-sufficient-performant-1"></a><a class="docs-heading-anchor-permalink" href="#Out-of-place-and-immutability-is-preferred-when-sufficient-performant" title="Permalink"></a></h2><p>Mutation is used to get more performance by decreasing the amount of heap allocations. However, if it&#39;s not helpful for heap allocations in a given spot, do not use mutation. Mutation is scary and should be avoided unless it gives an immediate benefit. For example, if matrices are sufficiently large, then <code>A*B</code> is as fast as <code>mul!(C,A,B)</code>, and thus writing <code>A*B</code> is preferred (unless the rest of the function is being careful about being fully non-allocating, in which case this should be <code>mul!</code> for consistency).</p><p>Similarly, when defining types, using <code>struct</code> is preferred to <code>mutable struct</code> unless mutating the struct is a common occurrence. Even if mutating the struct is a common occurrence, see whether using <a href="https://github.com/jw3126/Setfield.jl">Setfield.jl</a> is sufficient. The compiler will optimize the construction of immutable structs, and thus this can be more efficient if it&#39;s not too much of a code hassle.</p><h2 id="Tests-should-attempt-to-cover-a-wide-gamut-of-input-types"><a class="docs-heading-anchor" href="#Tests-should-attempt-to-cover-a-wide-gamut-of-input-types">Tests should attempt to cover a wide gamut of input types</a><a id="Tests-should-attempt-to-cover-a-wide-gamut-of-input-types-1"></a><a class="docs-heading-anchor-permalink" href="#Tests-should-attempt-to-cover-a-wide-gamut-of-input-types" title="Permalink"></a></h2><p>Code coverage numbers are meaningless if one does not consider the input types. For example, one can hit all the code with <code>Array</code>, but that does not test whether <code>CuArray</code> is compatible! Thus, it&#39;s always good to think of coverage not in terms of lines of code but in terms of type coverage. A good list of number types to think about are:</p><ul><li><code>Float64</code></li><li><code>Float32</code></li><li><code>Complex</code></li><li><a href="https://github.com/JuliaDiff/ForwardDiff.jl"><code>Dual</code></a></li><li><code>BigFloat</code></li></ul><p>Array types to think about testing are:</p><ul><li><code>Array</code></li><li><a href="https://github.com/JuliaArrays/OffsetArrays.jl"><code>OffsetArray</code></a></li><li><a href="https://github.com/JuliaGPU/CUDA.jl"><code>CuArray</code></a></li></ul><h2 id="When-in-doubt,-a-submodule-should-become-a-subpackage-or-separate-package"><a class="docs-heading-anchor" href="#When-in-doubt,-a-submodule-should-become-a-subpackage-or-separate-package">When in doubt, a submodule should become a subpackage or separate package</a><a id="When-in-doubt,-a-submodule-should-become-a-subpackage-or-separate-package-1"></a><a class="docs-heading-anchor-permalink" href="#When-in-doubt,-a-submodule-should-become-a-subpackage-or-separate-package" title="Permalink"></a></h2><p>Keep packages to one core idea. If there&#39;s something separate enough to be a submodule, could it instead be a separate well-tested and documented package to be used by other packages? Most likely yes.</p><h2 id="Globals-should-be-avoided-whenever-possible"><a class="docs-heading-anchor" href="#Globals-should-be-avoided-whenever-possible">Globals should be avoided whenever possible</a><a id="Globals-should-be-avoided-whenever-possible-1"></a><a class="docs-heading-anchor-permalink" href="#Globals-should-be-avoided-whenever-possible" title="Permalink"></a></h2><p>Global variables should be avoided whenever possible. When required, global variables should be constants and have an all uppercase name separated with underscores (e.g. <code>MY_CONSTANT</code>). They should be defined at the top of the file, immediately after imports and exports but before an <code>__init__</code> function. If you truly want mutable global style behavior you may want to look into mutable containers.</p><h2 id="Type-stable-and-type-grounded-code-is-preferred-wherever-possible"><a class="docs-heading-anchor" href="#Type-stable-and-type-grounded-code-is-preferred-wherever-possible">Type-stable and type-grounded code is preferred wherever possible</a><a id="Type-stable-and-type-grounded-code-is-preferred-wherever-possible-1"></a><a class="docs-heading-anchor-permalink" href="#Type-stable-and-type-grounded-code-is-preferred-wherever-possible" title="Permalink"></a></h2><p>Type-stable and type-grounded code helps the compiler create not only more optimized code, but also faster to compile code. Always keep containers well-typed, functions specializing on the appropriate arguments, and types concrete.</p><h2 id="Closures-should-be-avoided-whenever-possible"><a class="docs-heading-anchor" href="#Closures-should-be-avoided-whenever-possible">Closures should be avoided whenever possible</a><a id="Closures-should-be-avoided-whenever-possible-1"></a><a class="docs-heading-anchor-permalink" href="#Closures-should-be-avoided-whenever-possible" title="Permalink"></a></h2><p>Closures can cause accidental type instabilities that are difficult to track down and debug; in the long run it saves time to always program defensively and avoid writing closures in the first place, even when a particular closure would not have been problematic. A similar argument applies to reading code with closures; if someone is looking for type instabilities, this is faster to do when code does not contain closures. See examples <a href="https://discourse.julialang.org/t/are-closures-should-be-avoided-whenever-possible-still-valid-in-julia-v1-9/95893/5">here</a>.</p><p>Furthermore, if you want to update variables in an outer scope, do so explicitly with <code>Ref</code>s or self defined structs.</p><h2 id="Numerical-functionality-should-use-the-appropriate-generic-numerical-interfaces"><a class="docs-heading-anchor" href="#Numerical-functionality-should-use-the-appropriate-generic-numerical-interfaces">Numerical functionality should use the appropriate generic numerical interfaces</a><a id="Numerical-functionality-should-use-the-appropriate-generic-numerical-interfaces-1"></a><a class="docs-heading-anchor-permalink" href="#Numerical-functionality-should-use-the-appropriate-generic-numerical-interfaces" title="Permalink"></a></h2><p>While you can use <code>A\b</code> to do a linear solve inside a package, that does not mean that you should. This interface is only sufficient for performing factorizations, and so that limits the scaling choices, the types of <code>A</code> that can be supported, etc. Instead, linear solves within packages should use LinearSolve.jl. Similarly, nonlinear solves should use NonlinearSolve.jl. Optimization should use Optimization.jl. Etc. This allows the full generic choice to be given to the user without depending on every solver package (effectively recreating the generic interfaces within each package).</p><h2 id="Functions-should-capture-one-underlying-principle"><a class="docs-heading-anchor" href="#Functions-should-capture-one-underlying-principle">Functions should capture one underlying principle</a><a id="Functions-should-capture-one-underlying-principle-1"></a><a class="docs-heading-anchor-permalink" href="#Functions-should-capture-one-underlying-principle" title="Permalink"></a></h2><p>Functions mean one thing. Every dispatch of <code>+</code> should be &quot;the meaning of addition on these types&quot;. While in theory you could add dispatches to <code>+</code> that mean something different, that will fail in generic code for which <code>+</code> means addition. Thus, for generic code to work, code needs to adhere to one meaning for each function. Every dispatch should be an instantiation of that meaning.</p><h2 id="Internal-choices-should-be-exposed-as-options-whenever-possible"><a class="docs-heading-anchor" href="#Internal-choices-should-be-exposed-as-options-whenever-possible">Internal choices should be exposed as options whenever possible</a><a id="Internal-choices-should-be-exposed-as-options-whenever-possible-1"></a><a class="docs-heading-anchor-permalink" href="#Internal-choices-should-be-exposed-as-options-whenever-possible" title="Permalink"></a></h2><p>Whenever possible, numerical values and choices within scripts should be exposed as options to the user. This promotes code reusability beyond the few cases the author may have expected.</p><h2 id="Prefer-code-reuse-over-rewrites-whenever-possible"><a class="docs-heading-anchor" href="#Prefer-code-reuse-over-rewrites-whenever-possible">Prefer code reuse over rewrites whenever possible</a><a id="Prefer-code-reuse-over-rewrites-whenever-possible-1"></a><a class="docs-heading-anchor-permalink" href="#Prefer-code-reuse-over-rewrites-whenever-possible" title="Permalink"></a></h2><p>If a package has a function you need, use the package. Add a dependency if you need to. If the function is missing a feature, prefer to add that feature to said package and then add it as a dependency. If the dependency is potentially troublesome, for example because it has a high load time, prefer to spend time helping said package fix these issues and add the dependency. Only when it does not seem possible to make the package &quot;good enough&quot; should using the package be abandoned. If it is abandoned, consider building a new package for this functionality as you need it, and then make it a dependency.</p><h2 id="Prefer-to-not-shadow-functions"><a class="docs-heading-anchor" href="#Prefer-to-not-shadow-functions">Prefer to not shadow functions</a><a id="Prefer-to-not-shadow-functions-1"></a><a class="docs-heading-anchor-permalink" href="#Prefer-to-not-shadow-functions" title="Permalink"></a></h2><p>Two functions can have the same name in Julia by having different namespaces. For example, <code>X.f</code> and <code>Y.f</code> can be two different functions, with different dispatches, but the same name. This should be avoided whenever possible. Instead of creating <code>MyPackage.sort</code>, consider adding dispatches to <code>Base.sort</code> for your types if these new dispatches match the underlying principle of the function. If it doesn&#39;t, prefer to use a different name. While using <code>MyPackage.sort</code> is not conflicting, it is going to be confusing for most people unfamiliar with your code, so <code>MyPackage.special_sort</code> would be more helpful to newcomers reading the code.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../style-guide/">« Style Guide</a><a class="docs-footer-nextpage" href="../../troubleshooting/">Troubleshooting »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.24 on <span class="colophon-date" title="Thursday 15 June 2023 07:03">Thursday 15 June 2023</span>. Using Julia version 1.9.1.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
